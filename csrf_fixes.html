<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Best Practices</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        .subheading {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .suboptheading {
            font-weight: bold;
        }

        .indent {
            margin-left: 20px;
        }
    </style>
</head>
<body>

<table>
    <thead>
        <tr>
            <th>Security Best Practices</th>
        </tr>
    </thead>

    <tbody>
        <tr><td valign="top"><p class="subheading">Phase: Architecture and Design</p>
            <div class="indent"><p class="suboptheading">Strategy: Libraries or Frameworks</p></div>            
            <div class="indent">Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.</div><br>
            <div class="indent">For example, use anti-CSRF packages such as the OWASP CSRFGuard. [<a href="https://cwe.mitre.org/data/definitions/352.html#REF-330">REF-330</a>] Another example is the ESAPI Session Management control, which includes a component for CSRF. [<a href="https://cwe.mitre.org/data/definitions/352.html#REF-45">REF-45</a>] </div><br>
        </td></tr>
        <tr><td valign="top"><p class="subheading">Phase: Implementation</p></div><br>
            <div class="indent">Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script. </div><br>
        </td></tr>
        <tr><td valign="top"><p class="subheading">Phase: Architecture and Design</p>
            <div class="indent">Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (<a href="https://cwe.mitre.org/data/definitions/330.html">CWE-330</a>). [<a href="https://cwe.mitre.org/data/definitions/352.html#REF-332">REF-332</a>] </div><br>
            <div class="indent"><span class = "suboptheading">Note:</span>Note that this can be bypassed using XSS (<a href="https://cwe.mitre.org/data/definitions/79.html">CWE-79</a>)</div><br>
        </td></tr>
        <tr><td valign="top"><p class="subheading">Phase: Architecture and Design</p>
            <div class="indent">Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation. </div><br>
            <div class="indent"><span class = "suboptheading">Note:</span>Note that this can be bypassed using XSS (<a href="https://cwe.mitre.org/data/definitions/79.html">CWE-79</a>)</div><br>
        </td></tr>
        <tr><td valign="top"><p class="subheading">Phase: Architecture and Design; Implementation</p>
            <div class="indent">Use the "double-submitted cookie" method as described by Felten and Zeller: </div><br>
            <div class="indent">When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same. </div><br>
            <div class="indent">Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult. </div><br>
            <div class="indent">This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [<a href="https://cwe.mitre.org/data/definitions/352.html#REF-331">REF-331</a>] </div><br>
            <div class="indent"><span class = "suboptheading">Note:</span>Note that this can probably be bypassed using XSS (<a href="https://cwe.mitre.org/data/definitions/79.html">CWE-79</a>), or when using web technologies that enable the attacker to read raw headers from HTTP requests.</div><br>
        </td></tr>
        <tr><td valign="top"><p class="subheading">Phase: Architecture and Design</p>
            <div class="indent">Do not use the GET method for any request that triggers a state change.</div><br>
        </td></tr>
        <tr><td valign="top"><p class="subheading">Phase: Implementation</p><br>
            <div class="indent">Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons. </div><br>
            <div class="indent"><span class = "suboptheading">Note:</span>Note that this can be bypassed using XSS (<a href="https://cwe.mitre.org/data/definitions/79.html">CWE-79</a>). An attacker could use XSS to generate a spoofed Referer, or to generate a malicious request from a page whose Referer would be allowed. </div><br>
        </td></tr>
     </tbody>
</table>
<p>Click <a href="https://www.savi-scanneronline.com">here</a> to return to the main scanner page</p>
</body>
</html>
